# -*- coding: utf-8 -*-
"""Final_data

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_udKdBcNzBIJdHGcWgh6udLcfk2xB_w6
"""

import pandas as pd

df = pd.read_csv('final_dataset.csv')
# natural language processing: n-gram ranking
import re
import unicodedata
import nltk
nltk.download('stopwords')
nltk.download('wordnet')
from sklearn import svm
import matplotlib.pyplot as plt
from mlxtend.plotting import plot_decision_regions
import numpy as np
from nltk.corpus import stopwords  # add appropriate words that will be ignored in the analysis

x = df['Body'].values
var = x.shape
y = df['Label'].values
var1 = y.shape

from sklearn.model_selection import train_test_split

(x_train, x_test, y_train, y_test) = train_test_split(x, y, test_size=0.2)
shape1 = x_train.shape
shape2 = y_train.shape
shape3 = x_test.shape
shape4 = y_test.shape

df1 = pd.DataFrame(x_train)
df1 = df1.rename(columns={0: 'Body'})

df2 = pd.DataFrame(y_train)
df2 = df2.rename(columns={0: 'label'})
df_train = pd.concat([df1, df2], axis=1)
df_train.head()
print(df_train)

df3 = pd.DataFrame(x_test)
df3 = df3.rename(columns={0: 'Body'})
df4 = pd.DataFrame(y_test)
df4 = df4.rename(columns={0: 'Label'})
df_test = pd.concat([df3, df4], axis=1)
print(df_test)

ADDITIONAL_STOPWORDS = [ '\n', 'n']
mails=[]
labels=[]
mails_test=[]
labels_test=[]

for index, column in df_train.iterrows():
    label = column[1]
    message_text = column[0]
    mails.append(message_text)
    labels.append(label)
for index, column in df_test.iterrows():
    label1 = column[1]
    message_text1 = column[0]
    mails_test.append(message_text1)
    labels_test.append(label1)
print(len(mails))

    
stopwords = nltk.corpus.stopwords.words('english') + ADDITIONAL_STOPWORDS

from nltk.stem import PorterStemmer
from sklearn.feature_extraction.text import CountVectorizer

def basic_clean(text):
    """
      A simple function to clean up the data. All the words that
      are not designated as a stop word is then lemmatized after
      encoding and basic regex parsing are performed.
    """
    wnl = nltk.stem.WordNetLemmatizer()
    stopwords = nltk.corpus.stopwords.words('english') + ADDITIONAL_STOPWORDS
    text = (unicodedata.normalize('NFKD', text)
            .encode('ascii', 'ignore')
            .decode('utf-8', 'ignore')
            .lower())
    words = re.sub(r'[^\w\s]', '', text).split()
    return [wnl.lemmatize(word) for word in words if word not in stopwords]

cleaned_mails=[]
for i in range(len(mails)):
  cleaned_mails.append(' '.join(basic_clean(mails[i])))

cleaned_mails_test=[]
for i in range(len(mails_test)):
  cleaned_mails_test.append(' '.join(basic_clean(mails_test[i])))

cv= CountVectorizer(ngram_range=(1,3),min_df=0.1)
count_vector = cv.fit_transform(cleaned_mails)
cv_test=cv.transform(cleaned_mails_test)
print(cv.vocabulary_)

from sklearn.metrics import accuracy_score
X = count_vector
y=labels
model_svm = svm.SVC(kernel='linear',decision_function_shape='ovo')
clf = model_svm.fit(X, y)
print(accuracy_score(clf.predict(X), y))
print(accuracy_score(clf.predict(cv_test), df_test["Label"]))

from sklearn.naive_bayes import MultinomialNB
X = count_vector
Y = labels

model_mnb = MultinomialNB()

mnb = model_mnb.fit(X, Y)
print(accuracy_score(mnb.predict(X), y))
print(accuracy_score(mnb.predict(cv_test), df_test["Label"]))

from sklearn.naive_bayes import BernoulliNB
X = count_vector
Y = labels

model_bnb = BernoulliNB()

bnb = model_bnb.fit(X, Y)
print(accuracy_score(bnb.predict(X), y))
print(accuracy_score(bnb.predict(cv_test), df_test["Label"]))

from sklearn import tree

X = count_vector
Y = labels

model_tree = tree.DecisionTreeClassifier()
tre = model_tree.fit(X,Y)
print(accuracy_score(tre.predict(X), y))
print(accuracy_score(tre.predict(cv_test), df_test["Label"]))

X = count_vector
Y = labels
from sklearn.linear_model import LogisticRegression
lor = LogisticRegression(random_state = 0)
lor.fit(X,y)
print(accuracy_score(lor.predict(X), y))
print(accuracy_score(lor.predict(cv_test), df_test["Label"]))

import matplotlib